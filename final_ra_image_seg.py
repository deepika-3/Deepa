# -*- coding: utf-8 -*-
"""Final RA image seg.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Zp_oe3vJXqysRZ7ipy5txCPiovpHJcR5
"""

!pip install nibabel matplotlib numpy scikit-image

import sys
print(sys.version)



output_dir = "/content/sample_data/RA output"
os.makedirs(output_dir, exist_ok=True)

# Loading the .nii.gz file

nii_image = nib.load("/content/3702_left_knee.nii.gz")
image_data = nii_image.get_fdata()
print(image_data)


# Selecting a 2D slice from the 3D image (e.g., middle slice) in order to reduce computation
# and complexicity

for i in range(num_slices):
    # ... your segmentation logic ...
    image_slice = image_data[:, :, i]

    if np.max(image_slice) == 0:
        print(f"Skipping blank slice {i}")
        continue

    # Segmentation is dividing the image , seperating the object from foreground to background we have to
# Perform simple thresholding (Otsu's method) for that Applying Otsu's thresholding

    thresh = threshold_otsu(image_slice)
    binary_mask = image_slice > thresh

    # Normalize image_slice to 0-1 for proper saving
    norm_slice = (image_slice - np.min(image_slice)) / (np.ptp(image_slice) + 1e-8)

    original_path = f"{output_dir}/slice_{i:03d}_original.png"
    mask_path = f"{output_dir}/slice_{i:03d}_mask.png"

    plt.imsave(original_path, norm_slice, cmap='gray')
    plt.imsave(mask_path, binary_mask.astype(np.uint8), cmap='gray')

import shutil

shutil.make_archive("/content/RA_output", 'zip', "/content/sample_data/RA output")

from google.colab import files
files.download("/content/RA_output.zip")